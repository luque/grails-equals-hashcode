<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>1 User Guide</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="1 User Guide">1 User Guide</a></h1>This plugin provides a base <a href="http://code.google.com/p/spock/" target="blank">Spock</a> specification for testing equals and hashCode methods. You can use it to test both Grails domain classes and other Groovy objects.<p class="paragraph"/>It depends on the <a href="http://www.grails.org/plugin/spock" target="blank">Grails Spock plugin</a> which in turn depends on Spock <code>0.5-groovy-1.7</code> version.<h2><a name="1.1 How to use the plugin">1.1 How to use the plugin</a></h2>We have a domain class where we implemented <code>equals</code> and <code>hashCode</code> methods (with Apache Commons Lang builders). <code>includedSampleProperty</code> is used in <code>equals</code>/<code>hashCode</code>, whereas <code>ignoredSampleProperty</code> is not a part of object's equality.
<div class="code"><pre>class DomainObject &#123;
    def includedSampleProperty
    def ignoredSampleProperty<p class="paragraph"/>    <span class="java&#45;object">boolean</span> equals(o) &#123;
        <span class="java&#45;keyword">if</span> (o == <span class="java&#45;keyword">null</span>) <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">false</span>
        <span class="java&#45;keyword">if</span> (<span class="java&#45;keyword">this</span>.is(o)) <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">true</span>
        <span class="java&#45;keyword">if</span> (!(o <span class="java&#45;keyword">instanceof</span> DomainObject)) <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">false</span><p class="paragraph"/>        DomainObject that = (DomainObject) o;
        <span class="java&#45;keyword">new</span> EqualsBuilder().append(includedSampleProperty, that.includedSampleProperty).isEquals()
    &#125;<p class="paragraph"/>    <span class="java&#45;object">int</span> hashCode() &#123;
        <span class="java&#45;keyword">new</span> HashCodeBuilder().append(includedSampleProperty).toHashCode()
    &#125;
&#125;</pre></div><p class="paragraph"/>We should test both <code>equals</code> and <code>hashCode</code> methods if they:
<ul class="star">
<li>fulfill <code>equals</code> and <code>hashCode</code> contracts as specified in <code><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" class="api">Object</a></code> Javadoc (see below)</li>
<li>use some properties in <code>equals</code>/<code>hashCode</code></li>
<li>ignore some properties (i.e. if their value change, and the remaining properties stay unchanged, <code>equals</code> and <code>hashCode</code> should return the same value as before change)</li>
</ul><p class="paragraph"/>To keep your code DRY, extend <code>EqualsHashCodeSpec</code> (which in turn extend <code>UnitSpec</code>) and:
<ul class="star">
<li>override the factory method <code>createDomainObjectToCompare</code> that spawns a new object under test</li>
<li>override the method <code>modifiedPropertiesIncludedInEqualsAndHashCode</code> that returns a map of property names used in <code>equals</code>/<code>hashCode</code> and their values changed with respect to the object created by <code>createDomainObjectToCompare</code></li>
<li>optionally override the method <code>modifiedPropertiesIgnoredInEqualsAndHashCode</code> for properties NOT used in <code>equals</code>/<code>hashCode</code></li>
</ul><p class="paragraph"/>Example for our sample <code>DomainObject</code>:
<div class="code"><pre>class DomainObjectSpec <span class="java&#45;keyword">extends</span> EqualsHashCodeSpec &#123;<p class="paragraph"/>    def createDomainObjectToCompare() &#123;
        <span class="java&#45;keyword">new</span> DomainObject(includedSampleProperty: 'foo', ignoredSampleProperty: 'bar')
    &#125;<p class="paragraph"/>    def modifiedPropertiesIncludedInEqualsAndHashCode() &#123;
        &#91;includedSampleProperty: 'foo changed'&#93;
    &#125;<p class="paragraph"/>    def modifiedPropertiesIgnoredInEqualsAndHashCode() &#123;
        &#91;ignoredSampleProperty: 'bar changed'&#93;
    &#125;
&#125;</pre></div><p class="paragraph"/><h2><a name="1.2 How the plugin works">1.2 How the plugin works</a></h2><code>EqualsHashCodeSpec</code> applies a  <em class="italic">One Bad Attribute</em>  pattern (variation of  <em class="italic"><a href="http://xunitpatterns.com/Derived%20Value.html" target="blank">Derived Value</a></em> ). For each property used and ignored in <code>equals</code>/<code>hashCode</code>, <code>createDomainObjectToCompare</code> creates two objects to compare. One of the objects is modified - a single property value is changed.<p class="paragraph"/>Tests with changed properties used in <code>equals</code>/<code>hashCode</code> verify that two objects are not equal. They don't check if hashCode values of different objects are the same (although a good implementation of <code>hashCode</code> should return distinct values for unequal objects).<p class="paragraph"/>Tests with properties ignored in <code>equals</code>/<code>hashCode</code> verify that two objects are equal and hash codes are the same (although a property value is different in two objects).
<h2><a name="1.3 equals and hashCode contracts">1.3 equals and hashCode contracts</a></h2>According to <code><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" class="api">Object</a></code> Javadoc, <code>equals</code>:<p class="paragraph"/><blockquote class="note">
<ul class="star">
<li>It is  <em class="italic">reflexive</em> : for any non-null reference value <code>x</code>, <code>x.equals(x)</code> should return <code>true</code>.</li>
<li>It is  <em class="italic">symmetric</em> : for any non-null reference values <code>x</code> and <code>y</code>, <code>x.equals(y)</code> should return <code>true</code> if and only if <code>y.equals(x)</code> returns <code>true</code>.</li>
<li>It is  <em class="italic">transitive</em> : for any non-null reference values <code>x</code>, <code>y</code>, and <code>z</code>, if <code>x.equals(y)</code> returns <code>true</code> and <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.</li>
</ul><p class="paragraph"/>It is  <em class="italic">consistent</em> : for any non-null reference values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in equals comparisons on the objects is modified.
For any non-null reference value <code>x</code>, <code>x.equals(null)</code> should return <code>false</code>.
</blockquote><p class="paragraph"/><code>hashCode</code> should be always implemented when equals is overriden and:<p class="paragraph"/><blockquote class="note">
<ul class="star">
<li>Whenever it is invoked on the same object more than once during an execution of a Java application, the <code>hashCode</code> method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</li>
<li>If two objects are equal according to the <code>equals(Object)</code> method, then calling the hashCode method on each of the two objects must produce the same integer result.</li>
<li>It is not required that if two objects are unequal according to the <code>equals(java.lang.Object)</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables.</li>
</ul><p class="paragraph"/>As much as is reasonably practical, the hashCode method defined by class <code>Object</code> does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the JavaTM programming language.)
</blockquote>
    </body>
</html>
